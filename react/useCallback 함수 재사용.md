# useCallback : 함수 재사용

컴포넌트가 렌더링 된다는 것은 누군가가 그 컴포넌트(함수형 컴포넌트)를 호출해서 실행되는 것을 말한다.

함수가 실행될 때마다 내부에 선언되어 있던 변수, 또다른 함수 등도 매번 다시 선언되어 사용됨 .

함수 선언, 재선언 자체는 메모리나 리소스 등을 많이 차지하는 것은 아니지만

한 번 만든 함수는 필요할 때만 새로 만들고 재사용하는 것이 중요하다. (=최적화 작업)

```jsx
const cachedFn = useCallback(fn, dependencies)
```

useCallback은 첫 번째 인자로 넘어온 함수를,

두 번째 인자로 넘어온 배열 형태의 함수 실행 조건의 값이 변경될 때까지 저장해놓고 재사용 할 수 있게 한다.

컴포넌트 안에 A라는 함수가 선언되어있을 때 A 함수는 해당 컴포넌트가 렌더링 될 때마다 새로 생성되는데,

useCallback을 사용하면 컴포넌트가 리랜더링 되더라도 의존하는 값들이 변하지 않는다면, A 함수가 재선언 되지 않고 재사용 할 수 있다.

### 💡 하지만

간단한 수준의 함수 재선언을 막기 위해 useCallback을 사용하는 것은 그다지 의미있어 보이진 않는다. 위에서 언급했듯 함수 선언, 재선언 자체는 메모리나 리소스 등을 많이 차지하진 않기 때문임.

공식문서에 따르면 useCallback은 이런 상황에 사용해야 유용한 듯하다.

👉 만약 하위 컴포넌트가 최적화 되어 있고(React.memo), 그 하위 컴포넌트에서 콜백함수를 props로 넘길 때, 상위 컴포넌트에서 해당 함수를 useCallback으로 선언하는 것.

상위 컴포넌트에서 콜백함수를 같은 함수이더라도 재선언한다면, props로 콜백함수를 넘겨받는 하위 컴포넌트 입장에서는 props가 변경되었다고 인식함.

하위 컴포넌트에 최적화 설정을 해주지 않으면 부모에게서 받는 props가 변경되지 않더라도 리렌더링 되는게 기본이기 때문…

useCallback은 React.memo와 함께 사용해야 실질적인 렌더링 최적화를 할 수 있을 듯 하다.

---

참고

[https://www.youtube.com/watch?v=uBmnf_k7_r0&t=266s](https://www.youtube.com/watch?v=uBmnf_k7_r0&t=266s)