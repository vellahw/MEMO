# 면접준비 231017

## 1. 자신의 강점과 약점?

제 강점은 강한 책임감과 꼼꼼함입니다. 이전의 사회 생활, 교육 기관에서의 프로젝트에서 제가 해본 적 없는 일을 맡게 되어도 책임감 키워드 하나로 맡은 임무를 최대한 수행했고, 놓쳐지는 부분이 없도록 체크리스트를 만들어 진행하곤 했습니다.

약점은 속도가 더딘 것입니다. 꼼꼼하게 일을 수행하겠다는 다짐이 있어서 하나하나 살펴보고 빠져들다보니 종종 데드라인 마지막날 밤을 샜던 경험이 있습니다. 우선순위를 파악하고 계획을 짜면서 약점을 보완하고 있습니다.

## ****2. 어떤 프레임워크를 사용하여 개발했나요? 왜 그 프레임워크를 선택했나요?****

리액트를 사용해 개발했습니다. 

리액트는 컴포넌트를 기반으로 하며, UI를 독립적인 컴포넌트로 나누어 개발할 수 있습니다. 따라서 코드의 재사용성과 유지보수성을 향상시킬 수 있는데, 이를 고민하던 때라 리액트를 선택하게 되었습니다.

## 3. 리액트를 사용하며 느낀점?

버튼이나, 네비게이션바 등을 직접 컴포넌트로 나눠보면서 앞서 말씀드린 재사용성과 유지보수성을 향상 시킬 수 있다는 것을 체감할 수 있었습니다. 또한 JSX와 스타일 컴포넌트를 사용하면서 UI 구성을 쉽고 빠르게 할 수 있었고 recoil 상태관리 라이브러리를 사용하며 상태에 따른 UI를 변경을 비교적 쉽게 할 수 있다는 것을 느낄 수 있었습니다.

## 4. JSX에 대해 설명

JSX는 자바스크립트를 확장한 문법으로, 공식문서에서 리액트와 함께 사용할 것을 권장하고 있습니다.

자바스크립트의 모든 기능이 포함되어 있으며, 리액트 요소를 생성하기 위해 사용됩니다.

## 5. 상태관리란?

우선 상태란 컴포넌트 내에서 변경 가능한 데이터를 의미하고, 이러한 데이터를 효율적으로 관리하는 것을 말합니다. 상태관리를 통해 데이터의 흐름과 컴포넌트 간의 상호작용을 조직화 할 수 있습니다.

## 6. 변수 선언, 초기화, 할당의 차이점

변수 선언은 변수를 생성하는 것을 의미합니다. 초기화는 메모리에 변수 저장을 위한 공간을 확보하는 것을 의미하고 기본적으로 undefined가 할당됩니다. 할당은 = 연산자를 사용하여 값을 할당하는 것입니다.

## 7. 생성자 함수?

생성자 함수는 new 키워드를 사용해 객체를 생성할 수 있는 함수를 말합니다. 

보통 함수의 이름은 대문자로 작성하며, 생성자 함수 안에서 this 키워드를 사용해 객체의 속성을 지정합니다. 

## 8. this에 대해 설명

this 키워드를 통해 자신이 속한 객체의 속성에 접근하거나 수정, 다른 함수를 호출하는 등의 다양한 작업을 할 수 있습니다. this의 값은 함수가 호출 될 때에 따라 동적으로 결정되고 어디서 호출되느냐에 따라 값이 달라집니다.

예를 들어 전역에서 사용될 때 일반적으로 window 객체를 가리키고,

객체의 메서드로 함수를 호출하면 그 객체를 가리킵니다.

## 9. call 함수를 아나요?

call() 함수는 this의 값을 직접 지정할 수 있게 합니다. 함수를 호출할 때 **`this`**가 어떤 객체를 가리키게 할지 명시적으로 지정할 수 있어 유용합니다.

## 10. 자바스크립트에서의 비동기 작업

우선 동기란 요청과 결과가 동시에 이루어지는 것이고 비동기는 동시에 이루어지지 않는 것을 말합니다.

네트워크 요청, 파일 읽기/쓰기, 타이머 등과 같이 시간이 걸리거나 지연될 수 있는 작업을 처리하는 데 사용됩니다.

비동기 작업을 처리하는 방법으로 콜백 함수, Promise, async/await 등이 있습니다.

## 11. 콜백 함수란?

콜백 함수는 다른 함수의 인자로 넘겨지는 함수를 말합니다. 비동기 작업이 완료되었을 때 호출됩니다.

## 12. Promise란?

미래의 결과를 나타내는 객체입니다. 비동기 작업을 처리하면서 .then(), .catch() 등으로 성공 혹은 실패 후에 어떤 작업을 처리할지 정의 할 수 있습니다.

```jsx
function successCallback(result) {
  console.log("Audio file ready at URL: " + result);
}

function failureCallback(error) {
  console.log("Error generating audio file: " + error);
}

// createAudioFileAsync(audioSettings).then(successCallback, failureCallback);

// 위를 모던하게 리팩터링
const promise = createAudioFileAsync(audioSettings);
promise.then(successCallback, failureCallback);
```

## 13. async/await

async와 await를 사용하면 Promise를 보다 쉽게 사용할 수 있습니다.

async로 함수 내에서 await 키워드를 사용하면 비동기 작업이 끝나기 전까지 다음 단계로 넘어가지 않습니다. 

## 14. 이벤트 위임에 대해

이벤트 위임은 여러 요소를 다룰 때 사용됩니다. 각 요소에 이벤트 핸들러를 할당해주지 않고 부모 요소에 할당하여 자식으로 위임해주는 구조입니다.

## 15. 최근 기술적으로 해결한 경험

이력서에는 작성하지 않았지만 최근 인턴으로 근무하며 랜딩 페이지를 클론하는 업무를 맡게 되었습니다. 리액트를 사용하여 개발하였는데, 추가 요구사항으로 og:meta를 이용한 미리보기 카드를 생성해야 했습니다. Helmet이라는 라이브러리도 사용해보았지만 일반 meta 태그와는 달리 og meta 태그는 SSR로 처리해주어야 했기 때문에 리액트로는 한계를 느꼈습니다. 비교적 쉽게 SSR을 할 수 있는 NextjJS로 프로젝트를 마이그레이션 하여 미리보기 카드 생성을 성공한 경험이 있습니다.

## 16. og:meta 태그를 왜 서버 측에서 렌더링 했어야 하는지

클라이언트 측에서는 주로 자바스크립트로 동적으로 콘텐츠를 렌더링하는데, SSR의 경우 이미 렌더링 된 HTML 문서가 전달됩니다. 

오픈 그래프의 경우에는 웹 페이지가 처음 로드될 때 브라우저의 크롤러나 소셜 미디어에서 정보를 읽어올 수 있어야 하므로 페이지의 메타 정보나 공유될 정보 등을 서버 측에서 렌더링하고 제공하는 것이 일반적이라고 생각합니다.